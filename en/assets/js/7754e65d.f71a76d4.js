"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["1385"],{49453:function(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/schema-form","metadata":{"permalink":"/react-admin-kit/en/components/schema-form","source":"@site/i18n/en/docusaurus-plugin-content-blog-blog1/schema-form/index.mdx","title":"SchemaForm - JSON Form","description":"Generates forms through a declarative schema configuration. The schema structure closely resembles Antd Table\'s columns.","date":"2025-01-01T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[],"frontMatter":{"date":"2025-01-01T00:00:00.000Z","sidebar_label":"SchemaForm:0:Core Components:0"},"unlisted":false,"nextItem":{"title":"ModalForm","permalink":"/react-admin-kit/en/components/modal-form"}},"content":"Generates forms through a declarative schema configuration. The schema structure closely resembles Antd Table\'s columns.\\r\\n\\r\\n## Basic Concepts\\r\\n\\r\\nA basic Schema form:\\r\\n\\r\\n<Previewer\\r\\n  title=\\"A basic Schema form\\"\\r\\n  src=\\"@@/SchemaForm/demos/basic-en/index.tsx\\"\\r\\n/>\\r\\n\\r\\nBefore diving deeper, let\'s clarify several key concepts.\\r\\n\\r\\nSchemaForm is built upon the [Antd Form](https://ant-design.antgroup.com/components/form) component. It generates form items by iterating through a **schema array**.\\r\\n\\r\\nIn this example, each object in the <i>columns array</i> represents a **schema**.\\r\\n\\r\\n```js\\r\\n{\\r\\n  title: \'Username\',\\r\\n  dataIndex: \'username\',\\r\\n  fieldProps: {\\r\\n    placeholder: \'Please enter username\'\\r\\n  },\\r\\n  formItemProps: {\\r\\n    rules: [\\r\\n      {\\r\\n        required: true,\\r\\n      },\\r\\n    ],\\r\\n  },\\r\\n},\\r\\n```\\r\\n\\r\\nIf written using Antd Form directly, this schema would generate:\\r\\n\\r\\n```js\\r\\nimport { Form, Input } from \'antd\';\\r\\n\\r\\n<Form>\\r\\n  <Form.Item\\r\\n    label=\\"Username\\"\\r\\n    name=\\"username\\"\\r\\n    rules={[\\r\\n      {\\r\\n        required: true,\\r\\n      },\\r\\n    ]}\\r\\n  >\\r\\n    <Input placeholder=\\"Please enter username\\" />\\r\\n  </Form.Item>\\r\\n</Form>;\\r\\n```\\r\\n\\r\\nIt\'s clear that in the schema:\\r\\n\\r\\n- `title` corresponds to Form.Item\'s `label`.\\r\\n- `dataIndex` corresponds to Form.Item\'s `name`.\\r\\n- `formItemProps` values are passed to the Form.Item component.\\r\\n- `fieldProps` values are passed to the component wrapped by Form.Item (Input in this example).\\r\\n\\r\\nLet\'s look at the second schema:\\r\\n\\r\\n```js | {4}\\r\\n{\\r\\n  title: \\"Gender\\",\\r\\n  dataIndex: \\"gender\\",\\r\\n  valueType: \\"radio\\",\\r\\n  fieldProps: {\\r\\n    options: [\\r\\n      { label: \\"Male\\", value: \\"male\\" },\\r\\n      { label: \\"Female\\", value: \\"female\\" },\\r\\n      { label: \\"Other\\", value: \\"other\\" },\\r\\n    ],\\r\\n  },\\r\\n};\\r\\n```\\r\\n\\r\\nThe difference from the first schema is the additional `valueType` field. Obviously, SchemaForm renders different components based on the `valueType` field. In this example, valueType: \'radio\' corresponds to a Radio.Group component, with options passed through fieldProps.\\r\\n\\r\\nThis is one of the advantages of using SchemaForm - most commonly used components can be rendered through `valueType`.\\r\\n\\r\\nThe **schema** part is now covered. Let\'s look at the **FormInstance**.\\r\\n\\r\\nThe [FormInstance](https://ant-design.antgroup.com/components/form#forminstance) is an important concept in Antd Form. Through the methods in the instance, we can perform many operations, such as: submitting forms, resetting forms, assigning values to forms, etc.\\r\\n\\r\\nIn SchemaForm, we get the _form instance_ through the `formRef` property.\\r\\n\\r\\n```js | {4}\\r\\nimport { useRef } from \'react\';\\r\\nimport { ProFormInstance, SchemaForm } from \'react-admin-kit\';\\r\\n\\r\\nconst formRef = useRef<ProFormInstance>() // Note: The type definition used here is ProFormInstance. It extends some methods based on antd form instance\\r\\n\\r\\n<SchemaForm\\r\\n  formRef={formRef}\\r\\n>\\r\\n\\r\\nformRef.current?.submit() // Submit\\r\\nformRef.current?.resetFields() // Reset\\r\\nformRef.current?.setFieldsValue() // Set values\\r\\n```\\r\\n\\r\\nOther methods in the _form instance_ will be introduced in detail later.\\r\\n\\r\\nThese are the basic concepts of SchemaForm. After reading this, you can already start writing some simple forms \u2728.\\r\\n\\r\\nAs you continue to use it, you can keep checking the various examples below to learn about other properties of SchemaForm. I believe you will become more and more proficient.\\r\\n\\r\\n### valueType\\r\\n\\r\\nThe valueType field is crucial in schema configuration, determining which form component gets rendered. Common types include `money`, `digit`, `date`, `dateRange`, `select`, `radio`, `textarea`, etc. (Complete list [here](https://procomponents.ant.design/en-US/components/schema#valuetype-lists)). When unspecified, defaults to Input.\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/valueType/index.tsx\\" />\\r\\n\\r\\nFor custom components, use `renderFormItem`. Custom components must follow Form.Item conventions (accept value/onChange props).\\r\\n\\r\\n```js\\r\\n{\\r\\n  renderFormItem: (schema, config, form) => {\\r\\n    return <MyComp />;\\r\\n  };\\r\\n}\\r\\n```\\r\\n\\r\\n### required\\r\\n\\r\\nSince required fields are common, SchemaForm provides a required shorthand for formItemProps: `{ rules: [{ required: true }]}`. formItemProps takes precedence.\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/required/index.tsx\\" />\\r\\n\\r\\n## Form Layouts\\r\\n\\r\\n### Traditional Layouts\\r\\n\\r\\n<Previewer title=\\"Horizontal\\" src=\\"@@/SchemaForm/demos/horizontal/index.tsx\\" />\\r\\n\\r\\n<Previewer title=\\"Vertical\\" src=\\"@@/SchemaForm/demos/vertical/index.tsx\\" />\\r\\n\\r\\n<Previewer title=\\"Inline\\" src=\\"@@/SchemaForm/demos/inline/index.tsx\\" />\\r\\n\\r\\n### Grid Mode\\r\\n\\r\\nGrid mode utilizes Ant Design\'s [Grid](https://ant-design.antgroup.com/components/grid) System, controlling layout through [Row](https://ant-design.antgroup.com/components/grid#row) and [Col](https://ant-design.antgroup.com/components/grid#col) props.\\r\\n\\r\\n```js | {2}\\r\\n<SchemaForm\\r\\n  grid\\r\\n  rowProps={{}}\\r\\n  colProps={{}}\\r\\n  columns={[\\r\\n    {\\r\\n      title: \'name\',\\r\\n      colProps: {}, // Higher priority\\r\\n    },\\r\\n    {\\r\\n      title: \'age\',\\r\\n      colProps: {}, // Higher priority\\r\\n    },\\r\\n  ]}\\r\\n/>\\r\\n```\\r\\n\\r\\nWhen `grid` is enabled, it renders as:\\r\\n\\r\\n```js | {3,4,10}\\r\\n// pseudocode for illustration only\\r\\n<Form>\\r\\n  <Row {...rowProps}>\\r\\n    <Col {...colProps}>\\r\\n      <Form.Item>\\r\\n        <Field />\\r\\n      <Form.Item>\\r\\n    </Col>\\r\\n\\r\\n    <Col {...colProps}>\\r\\n      <Form.Item>\\r\\n        <Field />\\r\\n      <Form.Item>\\r\\n    </Col>\\r\\n  </Row>\\r\\n</Form>\\r\\n```\\r\\n\\r\\nGrid system enables flexible layouts:\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/grid-en/index.tsx\\" />\\r\\n\\r\\n### Horizontal Grid Alignment\\r\\n\\r\\nIn horizontal grid mode, label widths may vary:\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/gridHorizontalInit-en/index.tsx\\" />\\r\\n\\r\\nSolutions include setting minimum widths:\\r\\n\\r\\n<Previewer\\r\\n  title=\\"Minimum Label Width\\"\\r\\n  src=\\"@@/SchemaForm/demos/gridHorizontalMinWidth-en/index.tsx\\"\\r\\n/>\\r\\n\\r\\nOr specifying individual widths:\\r\\n\\r\\n<Previewer\\r\\n  title=\\"Custom Label Widths\\"\\r\\n  src=\\"@@/SchemaForm/demos/gridHorizontal-en/index.tsx\\"\\r\\n/>\\r\\n\\r\\n> `labelCol` is an Antd Form prop that accepts Col props like `{span: 8}` or `{flex: \'0 0 30%\'}`.\\r\\n>\\r\\n> Values are calculated relative to the form item\'s width (divided into 24 units). `{span: 8}` means the label occupies 8/24 of the item\'s width.\\r\\n\\r\\n### Placeholder Spacing\\r\\n\\r\\nUse empty placeholders for forced line breaks.\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/placeholder/index.tsx\\" />\\r\\n\\r\\n## Form Operations\\r\\n\\r\\n### Readonly Mode\\r\\n\\r\\nEnable via `readonly` prop or schema\'s `readonly`. Key notes:\\r\\n\\r\\n1. Use `render` (not `renderFormItem`) for custom readonly displays\\r\\n2. Return null from render for empty space: `render: () => null`\\r\\n\\r\\n> \u{1F4A1} Rakjs extends the readonly render function\'s second parameter (record) to include all form values.\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/readonly-basic/index.tsx\\" />\\r\\n\\r\\n### Readonly Table Mode\\r\\n\\r\\nReadonly mode can also be transformed into a table-like format, similar to the <Link src={\'https://ant-design.antgroup.com/components/descriptions#api\'}>Antd Descriptions</Link> component.\\r\\n\\r\\n<Previewer\\r\\n  title=\\"readonlyType as description\\"\\r\\n  src=\\"@@/SchemaForm/demos/readonly-basic-description/index.tsx\\"\\r\\n/>\\r\\n\\r\\n### Field Dependencies\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/dependency-en/index.tsx\\" />\\r\\n\\r\\n### Initial Values and Value Assignment\\r\\n\\r\\n1. [Show User] defaults to No\\r\\n\\r\\n2. Toggles to Yes when clicking \\"Set Values\\"\\r\\n\\r\\n3. Resets to No when clicking \\"Reset\\"\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/init-value-basic-en/index.tsx\\" />\\r\\n\\r\\n### Submit Button\\r\\n\\r\\nThe `submitter` prop defaults to false. When enabled, automatically generates submit buttons.\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/submitter/index.tsx\\" />\\r\\n\\r\\nCustomize button props:\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/submitterProps/index.tsx\\" />\\r\\n\\r\\n### Readonly/Editable Toggle\\r\\n\\r\\nPractical scenarios:\\r\\n\\r\\n**1. Form Display Simulation**\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/readonly-form-en/index.tsx\\" />\\r\\n\\r\\n<Previewer\\r\\n  title=\\"readonlyType as descriptions\\"\\r\\n  src=\\"@@/SchemaForm/demos/readonly-form-descriptions-en/index.tsx\\"\\r\\n/>\\r\\n\\r\\n**2. Dependent Field Display in Readonly Mode**\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/readonly-render-en/index.tsx\\" />\\r\\n\\r\\n## Form Data\\r\\n\\r\\n### Value Retrieval\\r\\n\\r\\nSchemaForm provides multiple value retrieval methods. The most common is `onFinish`.\\r\\n\\r\\nOther methods via form instance:\\r\\n\\r\\n<Previewer inline src=\\"@@/SchemaForm/demos/formValueTable-en/index.tsx\\" />\\r\\n\\r\\nThese methods have subtle differences in handling formats and transformations.\\r\\n\\r\\n**Rule of thumb**: Use the first two methods when you need raw values, others for processed values.\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/formValue-en/index.tsx\\" />\\r\\n\\r\\n<Previewer inline src=\\"@@/SchemaForm/demos/formValueTableResult-en/index.tsx\\" />\\r\\n\\r\\n### ConvertValue and Transform\\r\\n\\r\\nBackend data often requires transformation before being used in form controls. (ConvertValue)\\r\\n\\r\\nSimilarly, form-collected data may need processing before being sent to the server. (Transform)\\r\\n\\r\\nThis is particularly common in scenarios like file attachments upload, where:\\r\\n\\r\\n```js\\r\\n// there is a upload component\\r\\n{\\r\\n  title: \'Files\',\\r\\n  dataIndex: \'fileList\',\\r\\n  renderFormItem: () => <FormUpload />\\r\\n}\\r\\n\\r\\n// <FormUpload /> expects: [{ name: \'FileA\', url: \'www.xx.com/xx\' }]\\r\\n\\r\\n// Backend returns for display: [{ id: 1, fileName: \'FileA\', filePath: \'www.xx.com/xx\' }]\\r\\n\\r\\n// Submission requires: fileIds: \'1,2\'\\r\\n```\\r\\n\\r\\n`convertValue` and `transform` handle these scenarios.\\r\\n\\r\\n<Previewer src=\\"@@/FormUpload/demos/dataSubmit-en/index\\" />\\r\\n\\r\\n> For file uploads, use the [FormUpload](/components/form-upload) component.\\r\\n\\r\\n### Convention Handling\\r\\n\\r\\nFor components like [Select](https://ant-design.antgroup.com/components/select) and [TreeSelect](https://ant-design.antgroup.com/components/tree-select), when the `labelInValue` property is enabled, the component no longer accepts strings but requires an object `{ label: string, value: string }` for display purposes.\\r\\n\\r\\nAs a result, the frontend needs to transform this data, and when submitting, the object must be split back into its original fields.\\r\\n\\r\\n```js\\r\\n// Example: A user dropdown component with labelInValue enabled\\r\\n{\\r\\n  title: \'User\',\\r\\n  dataIndex: \'user\',\\r\\n  valueType: \'select\',\\r\\n  fieldProps: {\\r\\n    labelInValue: true,\\r\\n    options: [\\r\\n      { value: 1, label: \'jack\' },\\r\\n      { value: 2, label: \'tom\' },\\r\\n    ]\\r\\n  }\\r\\n}\\r\\n\\r\\n// Backend returns userId: 1, userName: \'jack\' for display\\r\\n// => Frontend transforms into user: { value: 1, label: \'jack\' }\\r\\n// => On submission, the object is converted back to userId: 2, userName: \'tom\'\\r\\n```\\r\\n\\r\\nSince this scenario is quite common, RAK aims to simplify the process by introducing a convention for dataIndex, as follows:\\r\\n\\r\\n- \u{1F449} If dataIndex contains a comma `,`, RAK will automatically assemble an object based on the fields before and after the comma. During submission, the object will be split back. The field before the comma maps to value, and the field after maps to label.\\r\\n\\r\\n```js | {4,7}\\r\\n// Example: A user dropdown component with labelInValue enabled\\r\\n{\\r\\n  title: \'User\',\\r\\n  dataIndex: \'userId,userName\',\\r\\n  valueType: \'select\',\\r\\n  fieldProps: {\\r\\n    labelInValue: true,\\r\\n    options: [\\r\\n      { value: 1, label: \'jack\' },\\r\\n      { value: 2, label: \'tom\' },\\r\\n    ]\\r\\n  }\\r\\n}\\r\\n\\r\\n// With this convention, simply provide the values like this:\\r\\ninitialValues={{ userId: 1, userName: \'jack\' }}\\r\\n\\r\\n// Or:\\r\\nformRef.current?.setFieldsValue({ userId: 1, userName: \'jack\' })\\r\\n\\r\\n// Upon submission, the form will NOT receive:\\r\\n`{\'userId,userName\': { value: 1, label: \'jack\' }}`\\r\\n\\r\\n// Instead, it will receive:\\r\\n{\\r\\n  userId: 1,\\r\\n  userName: \'jack\'\\r\\n}\\r\\n```\\r\\n\\r\\n- If the component expects object keys other than `value` and `label`, you can customize them using an underscore. For example, `userId,userName_id,name` splits the underscore, where the fields after the underscore are also comma-separated. In this case, when assigning `{userId: 1, userName: \'jack\'}` to the component, the value will be transformed into `{` id: 1, name: \'jack\' }` before being passed to the component.\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/conventionSimple-en/index.tsx\\" />\\r\\n\\r\\n### Storing Additional Data with innerRef\\r\\n\\r\\n`innerRef` is a utility ref containing helpful methods for special scenarios.\\r\\n\\r\\nUse `innerRef.current?.setData()` to store extra data, consumable by other fields.\\r\\n\\r\\n> Similar to React\'s setState, setData merges updates.\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/innerRefData-en/index.tsx\\" />\\r\\n\\r\\n> For Embed Mode, pass innerRef to ProForm:\\r\\n>\\r\\n> ```js\\r\\n> import { ProForm } from \'react-admin-kit\';\\r\\n> import { useRef } from \'react\'\\r\\n>\\r\\n> const innerRef = useRef();\\r\\n> ...\\r\\n>\\r\\n> <ProForm\\r\\n>   innerRef={innerRef}\\r\\n>   ...\\r\\n> >\\r\\n> ...\\r\\n> </>\\r\\n> ```\\r\\n\\r\\n## Advanced Layouts\\r\\n\\r\\n### Embed Mode\\r\\n\\r\\nFor complex forms, using embed mode allows each section to have its own layout configuration while collecting data in separate objects through the `valueBaseName` property.\\r\\n\\r\\n```js | {4,6,7,12,13,19,20}\\r\\nimport { ProForm, SchemaForm } from \'react-admin-kit\';\\r\\nimport { Card } from \'antd\';\\r\\n\\r\\n<ProForm>\\r\\n  <SchemaForm embed valueBaseName=\\"one\\" />\\r\\n\\r\\n  <div>\\r\\n    <SchemaForm embed valueBaseName=\\"two\\" />\\r\\n  </div>\\r\\n\\r\\n  <Card>\\r\\n    <SchemaForm embed valueBaseName=\\"three\\" />\\r\\n  </Card>\\r\\n</ProForm>;\\r\\n\\r\\n// The collected form values upon submission will be: { one: ..., two: ..., three: ... }`\\r\\n```\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/embed-simple-en/index.tsx\\" />\\r\\n\\r\\n<Previewer\\r\\n  title=\\"readonlyType as descriptions in embed mode\\"\\r\\n  src=\\"@@/SchemaForm/demos/embed-simple-descriptions-en/index.tsx\\"\\r\\n/>\\r\\n\\r\\n> \u{1F449} Important note: In embed mode, the `valueBaseName` implementation simply converts the schema\'s dataIndex into an array format. See this Ant Design [example](https://ant.design/components/form/#components-form-demo-nest-messages).\\r\\n>\\r\\n> Therefore, when using setFieldsValue, you must include the valueBaseName in the value structure.\\r\\n>\\r\\n> ```js\\r\\n> setFieldsValue({ business: { company: \'xxx\' } });\\r\\n> ```\\r\\n>\\r\\n> For dependency controls, when valueType=\'dependency\' and `valueBaseName` has a value, the `name` property should use nested array syntax.\\r\\n>\\r\\n> ```js\\r\\n> { valueType: \'dependency\', name: [[\'business\', \'serviceName\']] } \u{1F448}\\r\\n>\\r\\n> ```\\r\\n\\r\\n### Group Layout\\r\\n\\r\\nWhen `valueType` is set to group, it enables grouped layout mode. Each group functions as a distinct section, with form items generated from the contents of columns.\\r\\n\\r\\nBy default, these form items are wrapped in Ant Design\'s [Space](https://ant.design/components/space/) component. Therefore, you can pass Space component\'s API properties through fieldProps.\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/group-en/index.tsx\\" />\\r\\n\\r\\n### Group Layout grid\\r\\n\\r\\nThe group layout operates at two levels:\\r\\n\\r\\n1. Outer layer (section title)\\r\\n\\r\\n2. Inner layer (form items within **columns**)\\r\\n\\r\\nAccordingly, `colProps` configurations must be specified separately for each level.\\r\\n\\r\\n<Previewer\\r\\n  title=\\"Group Grid Layout\\"\\r\\n  src=\\"@@/SchemaForm/demos/groupGrid-en/index.tsx\\"\\r\\n/>\\r\\n\\r\\n<Previewer\\r\\n  title=\\"Horizontal Group Grid Layout\\"\\r\\n  src=\\"@@/SchemaForm/demos/groupGridHorizontal-en/index.tsx\\"\\r\\n/>\\r\\n\\r\\n## Form Array\\r\\n\\r\\nWhen `valueType` is set to `formList`, it generates a form array, which is particularly useful for collecting **array-type** data.\\r\\n\\r\\nFor example, the following demo allows collecting multiple shop infomation:\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/formList-en/index.tsx\\" />\\r\\n\\r\\n`formList` is essentially a component, and its [API](https://procomponents.ant.design/en-US/components/group#proformlist-api) can be configured via fieldProps.\\r\\n\\r\\n### Grid Layout\\r\\n\\r\\nThe form items must be wrapped in valueType=\'group\'.\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/formListGrid-en/index.tsx\\" />\\r\\n\\r\\n### Custom Styling\\r\\n\\r\\nYou can further customize the styling and action buttons using the `itemRender` property. See the example for usage.\\r\\n\\r\\n> The `itemRender` function signature: `({ listDom, action }, options) => ReactNode`\\r\\n>\\r\\n> The `options` signature: `{name, field, index, record, fields, operations, meta}`\\r\\n\\r\\n<Previewer src=\\"@@/SchemaForm/demos/formListGridCustom-en/index.tsx\\" />\\r\\n\\r\\n## API\\r\\n\\r\\n### SchemaForm\\r\\n\\r\\nSchemaForm type is a combination of [SchemaFormSelfType](/components/schema-form#schemaformselftype) and [SchemaFormOriginType](/components/schema-form#schemaformorigintype).\\r\\n\\r\\n#### SchemaFormSelfType\\r\\n\\r\\n<API name=\\"SchemaFormSelfType\\" />\\r\\n\\r\\n#### SchemaFormOriginType\\r\\n\\r\\n<API name=\\"SchemaFormOriginType\\" />\\r\\n\\r\\n### SchemaFormInnerRefType\\r\\n\\r\\n<table className=\\"dumi-default-table-content\\">\\r\\n\\r\\n| Parameter | Description | Type | Default |\\r\\n| --- | --- | --- | --- |\\r\\n| data | Can be used to store extra data in the form | `Record<string, any>` | `{}` |\\r\\n| setData | Store data; setData works like React\'s setState, you only need to pass the fields you care about, and it will not overwrite other fields. | `(Record<string, any>) => void` | `--` |\\r\\n\\r\\n</table>\\r\\n\\r\\n### FormColumnType\\r\\n\\r\\n<API name=\\"FormColumnTypeComponent\\" />"},{"id":"/modal-form","metadata":{"permalink":"/react-admin-kit/en/components/modal-form","source":"@site/i18n/en/docusaurus-plugin-content-blog-blog1/modal-form/index.mdx","title":"ModalForm","description":"Generate a modal form through schema configuration.","date":"2025-01-02T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[],"frontMatter":{"date":"2025-01-02T00:00:00.000Z","sidebar_label":"ModalForm:1:Core Components:0"},"unlisted":false,"prevItem":{"title":"SchemaForm - JSON Form","permalink":"/react-admin-kit/en/components/schema-form"},"nextItem":{"title":"ProTable","permalink":"/react-admin-kit/en/components/protable"}},"content":"Generate a **modal form** through schema configuration.\\r\\n\\r\\nThis component combines <Link src=\'https://ant-design.antgroup.com/components/modal#api\'>Antd Modal</Link> and [SchemaForm](/components/schema-form), allowing you to pass through APIs from both components.\\r\\n\\r\\n## Basics\\r\\n\\r\\n### Basic Usage\\r\\n\\r\\n<Previewer src=\\"@@/ModalForm/demos/basic-en/index.tsx\\" />\\r\\n\\r\\n### Uncontrolled Mode (Recommended)\\r\\n\\r\\nUsing RAK\'s [innerRef](/components/modal-form#modalforminnerreftype) api, you can control the modal without defining an additional open variable, making it more concise. The following examples use this approach by default.\\r\\n\\r\\n<Previewer src=\\"@@/ModalForm/demos/innerRef-en/index.tsx\\" />\\r\\n\\r\\n### Form Types\\r\\n\\r\\nThe opened form has three types: `new`, `edit`, and `read`. You can also pass initial values.\\r\\n\\r\\n<Previewer src=\\"@@/ModalForm/demos/form-type-en/index.tsx\\" />\\r\\n\\r\\n### onFinish\\r\\n\\r\\nIn the `onFinish` callback function, you can implement different business logic based on the form type.\\r\\n\\r\\n<Previewer src=\\"@@/ModalForm/demos/onFinish-en/index.tsx\\" />\\r\\n\\r\\n### onOpen\\r\\n\\r\\nUse the `onOpen` callback to trigger API requests or perform other initialization tasks when the modal opens.\\r\\n\\r\\n<Previewer src=\\"@@/ModalForm/demos/onOpen-en/index.tsx\\" />\\r\\n\\r\\n## Layout\\r\\n\\r\\nPass [SchemaForm](/components/schema-form#schemaform) component APIs through the `formProps` property to change the form layout.\\r\\n\\r\\n### Multiple Columns\\r\\n\\r\\n<Previewer src=\\"@@/ModalForm/demos/multipleCol-en/index.tsx\\" />\\r\\n\\r\\n### Scroll to Error Field in Long Forms\\r\\n\\r\\n<Previewer src=\\"@@/ModalForm/demos/longForm-en/index.tsx\\" />\\r\\n\\r\\n## Form Operations\\r\\n\\r\\n### Show and Hide\\r\\n\\r\\nUse `valueType=dependency` for show/hide functionality.\\r\\n\\r\\n<Previewer src=\\"@@/ModalForm/demos/initValue-en/index.tsx\\" />\\r\\n\\r\\n## Form Data\\r\\n\\r\\nFor form data, please refer to [SchemaForm](/components/schema-form#form-data)\\r\\n\\r\\n### Convention-based\\r\\n\\r\\nLike [SchemaForm](/components/schema-form#convention-handling), ModalForm also supports convention-based data processing.\\r\\n\\r\\n<Previewer src=\\"@@/ModalForm/demos/convention-en/index.tsx\\" />\\r\\n\\r\\n### Store Additional Information with innerRef\\r\\n\\r\\nLike [SchemaForm](/components/schema-form#storing-additional-data-with-innerref), ModalForm can also store additional data using innerRef.\\r\\n\\r\\n<Previewer src=\\"@@/ModalForm/demos/innerRefData-en/index.tsx\\" />\\r\\n\\r\\n## API\\r\\n\\r\\n### ModalForm\\r\\n\\r\\nModalForm types are the combination of [ModalFormSelfType](/components/modal-form#modalformselftype) and <Link src=\'https://ant-design.antgroup.com/components/modal#api\'>Antd Modal</Link>.\\r\\n\\r\\n#### ModalFormSelfType\\r\\n<API name=\\"ModalFormType\\" typeStyles={{ minWidth: \'180px\' }} />\\r\\n\\r\\n### ModalFormInnerRefType\\r\\n\\r\\n<API name=\\"ModalFormInnerRefTypeComponent\\" />"},{"id":"/protable","metadata":{"permalink":"/react-admin-kit/en/components/protable","source":"@site/i18n/en/docusaurus-plugin-content-blog-blog1/protable/index.mdx","title":"ProTable","description":"ProTable combines the power of Antd ProTable with ModalForm, adding built-in delete and export features. It\'s designed for real-world admin scenarios where you need full CRUD functionality out of the box.","date":"2025-01-03T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[],"frontMatter":{"date":"2025-01-03T00:00:00.000Z","sidebar_label":"ProTable:2:Core Components:0"},"unlisted":false,"prevItem":{"title":"ModalForm","permalink":"/react-admin-kit/en/components/modal-form"},"nextItem":{"title":"BusinessSelect","permalink":"/react-admin-kit/en/components/business-select"}},"content":"import AreaImg from \'./area.png\';\\r\\n\\r\\n\\r\\nProTable combines the power of <Link src=\'https://procomponents.ant.design/components/table\'>Antd ProTable</Link> with [ModalForm](/components/modal-form), adding built-in delete and export features. It\'s designed for real-world admin scenarios where you need full CRUD functionality out of the box.\\r\\n\\r\\nNew to ProTable? No worries! The examples below will walk you through everything step by step.\\r\\n\\r\\n## Building Your First CRUD Table\\r\\n\\r\\nHere\'s a complete CRUD table with _search_, _create_, _edit_, and _delete_ functionality. If you\'re seeing ProTable for the first time, some of the APIs might look unfamiliar - that\'s totally normal! We\'ll break everything down into simple, digestible pieces.\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/basic-en/index.tsx\\" />\\r\\n\\r\\n### Fetching Data\\r\\n\\r\\nThe magic starts with the `request` property. Just pass in a function that fetches your data, and ProTable automatically handles pagination, searching, and table refreshing. Your request function should return a promise (like an axios call) with data in this format:\\r\\n\\r\\n```js\\r\\n// Your API should return data like this:\\r\\n{\\r\\n  data: [], // Array of table rows\\r\\n  success: true,\\r\\n  total: 6 // Total count for pagination\\r\\n}\\r\\n```\\r\\n\\r\\n```js\\r\\n<ProTable\\r\\n  request={(params) => requestApi(params)}\\r\\n  ...\\r\\n/>\\r\\n```\\r\\n\\r\\nProTable automatically passes pagination and search parameters to your request function:\\r\\n\\r\\n```js\\r\\n{\\r\\n  current: 2,        // Current page number\\r\\n  pageSize: 5,       // Items per page\\r\\n  name: \\"John\\",      // Search field values\\r\\n  // ... other search fields\\r\\n}\\r\\n```\\r\\n\\r\\nYou can either design your backend API to match this format, or transform the parameters in your request function.\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/retrieve-en/index.tsx\\" />\\r\\n\\r\\n### Adding Create Functionality\\r\\n\\r\\nNow let\'s add a \\"Create\\" button. ProTable has designated areas for different types of buttons, which keeps your tables organized and user-friendly. You just need to put buttons in the right spots!\\r\\n\\r\\n<div style={{ textAlign: \'center\' }}>\\r\\n  <img\\r\\n    src={AreaImg}\\r\\n    width=\\"100%\\"\\r\\n    alt=\\"Division of protable areas, red text represents large blocks, divided into search, toolbar, tableAlert and other areas. The toolbar block also contains actions sub-blocks\\"\\r\\n  />\\r\\n</div>\\r\\n\\r\\nThe red labels show the main areas, and black labels show sub-areas within them. For a \\"Create\\" button, the best place is in the `actions` area within the `toolbar` (you could also put it in the `title` area).\\r\\n\\r\\n```js {2,3}\\r\\n<ProTable\\r\\n  toolbar={{\\r\\n    actions: [\\r\\n      <Button\\r\\n        key={1}\\r\\n        type=\\"primary\\"\\r\\n      >\\r\\n        Create\\r\\n      </Button>,\\r\\n    ],\\r\\n  }}\\r\\n```\\r\\n\\r\\nOnce you have the button, use `innerRef.current.openModal()` to open the create form.\\r\\n\\r\\n```js {2,8}\\r\\n<ProTable\\r\\n  innerRef={innerRef}\\r\\n  toolbar={{\\r\\n    actions: [\\r\\n      <Button\\r\\n        key={1}\\r\\n        type=\\"primary\\"\\r\\n        onClick={() => innerRef.current.openModal()}\\r\\n      >\\r\\n        Create\\r\\n      </Button>,\\r\\n    ],\\r\\n  }}\\r\\n```\\r\\n\\r\\nFinally, add an `onFinish` handler to save the new record.\\r\\n\\r\\n```js {21}\\r\\n<ProTable\\r\\n  columns={getColumns()}\\r\\n  request={mockRequest}\\r\\n  pagination={{ pageSize: 5 }}\\r\\n  innerRef={innerRef}\\r\\n  toolbar={{\\r\\n    actions: [\\r\\n      <Button\\r\\n        key={1}\\r\\n        type=\\"primary\\"\\r\\n        onClick={() => innerRef.current?.openModal()}\\r\\n      >\\r\\n        Create\\r\\n      </Button>,\\r\\n    ],\\r\\n  }}\\r\\n  onFinish={async (values, formType) => {\\r\\n    if (formType === \'new\') {\\r\\n      await mockAdd(values);\\r\\n      message.success(\'Created successfully\');\\r\\n      actionRef.current?.reload(); // Refresh the table after creating\\r\\n    }\\r\\n  }}\\r\\n/>\\r\\n```\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/create-en/index.tsx\\" />\\r\\n\\r\\n### Adding Edit Functionality\\r\\n\\r\\nTo add editing, we need an \\"Actions\\" column with an \\"Edit\\" button for each row.\\r\\n\\r\\n```js {5,8}\\r\\n// columns\\r\\n{\\r\\n  title: \'Actions\',\\r\\n  valueType: \'option\', // \'option\' means this is an actions column\\r\\n  render: (text, record, index, actionRef, innerRef) => [\\r\\n    <LinkButton\\r\\n      key={1}\\r\\n      onClick={() => innerRef.current?.openModal(\'edit\', record)}\\r\\n    >\\r\\n      Edit\\r\\n    </LinkButton>,\\r\\n  ],\\r\\n},\\r\\n```\\r\\n\\r\\nWhen `valueType` is `option`, ProTable automatically provides the `innerRef` parameter to your render function. Use it to open the edit modal with the row\'s data pre-filled.\\r\\n\\r\\nNow let\'s handle the update logic in `onFinish`:\\r\\n\\r\\n```js {11}\\r\\n<ProTable\\r\\n  ...\\r\\n  onFinish={async (values, formType, formData) => {\\r\\n    if (formType === \'new\') {\\r\\n      await mockAdd(values);\\r\\n      message.success(\'Created successfully\');\\r\\n      actionRef.current?.reload();\\r\\n    }\\r\\n\\r\\n    if (formType === \'edit\') {\\r\\n      await mockUpdate({ ...values, id: formData.id });\\r\\n      message.success(\'Updated successfully\');\\r\\n      actionRef.current?.reload();\\r\\n    }\\r\\n  }}\\r\\n/>\\r\\n```\\r\\n\\r\\nNotice on line 11: we need the record\'s ID for the update API, but the form `values` don\'t include it.\\r\\n\\r\\nHere\'s the trick: `onFinish` gets three parameters:\\r\\n\\r\\n- `values` - the form data the user entered\\r\\n- `formType` - whether it\'s \'new\' or \'edit\'\\r\\n- `formData` - the original record data (including the ID!)\\r\\n\\r\\nThe `formData` is the same `record` you passed to `innerRef.current?.openModal(\'edit\', record)`.\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/update-en/index.tsx\\" />\\r\\n\\r\\n### Adding Delete Functionality\\r\\n\\r\\nDelete works just like the `request` property - simple and automatic! Just provide a `delFunction`, and ProTable handles both bulk delete and individual row delete.\\r\\n\\r\\nYour delete function should return a promise and will receive an array of IDs for the selected rows.\\r\\n\\r\\nFor bulk delete, you\'ll also need to enable row selection:\\r\\n\\r\\n```js {4}\\r\\n<ProTable\\r\\n  ...\\r\\n  delFunction={mockDetroy}\\r\\n  rowSelection={{}}\\r\\n/>\\r\\n```\\r\\n\\r\\nIndividual row delete buttons are hidden by default (to save space), but you can enable them per column:\\r\\n\\r\\n```js {13-21}\\r\\n// columns\\r\\n{\\r\\n  title: \'Actions\',\\r\\n  valueType: \'option\', // valueType set to option represents an action column\\r\\n  render: (text, record, index, actionRef, innerRef) => [\\r\\n    <LinkButton\\r\\n      key={1}\\r\\n      onClick={() => innerRef.current?.openModal(\'edit\', record)}\\r\\n    >\\r\\n      Edit\\r\\n    </LinkButton>,\\r\\n  ],\\r\\n  // Simple enable/disable\\r\\n  enableDelete: true,\\r\\n  // Or customize the delete button\\r\\n  enableDelete: () => ({\\r\\n    disabled: true,\\r\\n    visible: true,\\r\\n    danger: true,\\r\\n    btnText: \'Close\'\\r\\n  }),\\r\\n},\\r\\n```\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/destroy-en/index.tsx\\" />\\r\\n\\r\\nAnd that\'s it - you\'ve built a complete CRUD table! \u2728\\r\\n\\r\\n## Key Concepts\\r\\n\\r\\n### valueType \\r\\n\\r\\nProTable supports `valueType` just like SchemaForm, but here it\'s focused on display formatting. For example, set `valueType: \'date\'` and ProTable will automatically convert timestamps into readable dates.\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/valueType/index.tsx\\" />\\r\\n\\r\\n### renderText vs render - What\'s the Difference?\\r\\n\\r\\nThese two are easy to mix up, so here\'s the breakdown:\\r\\n\\r\\n**`renderText`** - Similar to Ant Design Table\'s render, but must return a string. ProTable will add ellipsis, copy icons, and other features around your text.\\r\\n\\r\\n**`render`** - Complete control over the display. The first parameter is `dom` (not `text`), which already includes ellipsis and copy icons that you can use or replace.\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/renderText-en/index.tsx\\" />\\r\\n\\r\\n### Configuring the Search Area\\r\\n\\r\\nControl which columns appear in the search form:\\r\\n\\r\\n```js {4,5}\\r\\n{\\r\\n  title: \'Nickname\',\\r\\n  dataIndex: \'nickName\',\\r\\n  hideInSearch: true, // Don\'t show in search\\r\\n  search: false, // Same as above\\r\\n}\\r\\n```\\r\\n\\r\\nOr disable search entirely:\\r\\n\\r\\n```js\\r\\n<ProTable search={false} />\\r\\n```\\r\\n\\r\\nYou can also customize search behavior:\\r\\n\\r\\n```js\\r\\n<ProTable\\r\\n  search={{\\r\\n    labelWrap: true, // Wrap long labels\\r\\n    defaultCollapsed: false, // Start expanded\\r\\n  }}\\r\\n/>\\r\\n```\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/searchConfig-en/index.tsx\\" />\\r\\n\\r\\n### Using `type` to Control Column Placement\\r\\n\\r\\nProTable uses the same column definitions for the table, search form, and edit form. Instead of using multiple `hideIn*` properties (which gets confusing), you can use the `type` field to specify exactly where a column should appear:\\r\\n\\r\\n```js\\r\\n{\\r\\n  title: \'Search Only Field\',\\r\\n  type: \'search\'  // Only appears in search form\\r\\n}\\r\\n```\\r\\n\\r\\nAvailable types: `\'form\' | \'table\' | \'search\'`\\r\\n\\r\\n> **Note:** `type` has the highest priority and overrides `hideInSearch` and `search: false`\\r\\n\\r\\nYou can also set a global default with `defaultHideInSearch` to control whether columns appear in search by default.\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/columnType-en/index.tsx\\" />\\r\\n\\r\\n### Making Search Fields Depend on Each Other \\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/searchDependency-en/index.tsx\\" />\\r\\n\\r\\n### Controlled Table\\r\\n\\r\\nDon\'t want automatic data loading? No problem! You can use ProTable like a regular table by providing your own data, while still getting the create and edit features.\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/controlled-en/index.tsx\\" />\\r\\n\\r\\n### Exporting Table Data to Excel\\r\\n\\r\\nProTable makes Excel export super easy using <Link src=\'https://github.com/exceljs/exceljs\'>exceljs</Link>. The data formatting is handled for you!\\r\\n\\r\\nFirst, install exceljs:\\r\\n\\r\\n```bash\\r\\nnpm i exceljs --save\\r\\n```\\r\\n\\r\\nThen import it:\\r\\n\\r\\n```tsx\\r\\nimport * as ExcelJS from \'exceljs\';\\r\\n```\\r\\n\\r\\nExport with one command: `innerRef.current?.export(rows, ExcelJS)`\\r\\n\\r\\n<Previewer title=\\"Export All\\" src=\\"@@/ProTable/demos/export-en/index.tsx\\" />\\r\\n\\r\\n<Previewer\\r\\n  title=\\"Export Selected Rows\\"\\r\\n  src=\\"@@/ProTable/demos/export-selected-en/index.tsx\\"\\r\\n/>\\r\\n\\r\\n### Customizing Delete Confirmations\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/destroy2-en/index.tsx\\" />\\r\\n\\r\\n## Working with Modals\\r\\n\\r\\n### Customizing Modal Layout\\r\\n\\r\\nUse `modalFormProps` to pass any [ModalForm](/components/setting-provider#modalformsettingprops) properties and customize your modal\'s appearance.\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/modalFormLayout-en/index.tsx\\" />\\r\\n\\r\\n### Read-Only Modal Mode\\r\\n\\r\\nWant to show data without allowing edits? Use read-only mode:\\r\\n\\r\\n`innerRef.current?.openModal(\'read\', initialData)`\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/readonly-en/index.tsx\\" />\\r\\n\\r\\n## Handling Form Data\\r\\n\\r\\n### Loading Data When Opening Forms\\r\\n\\r\\nSometimes you need to fetch additional data when opening an edit form (but not for create). Here\'s how:\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/onOpen-en/index.tsx\\" />\\r\\n\\r\\n### Convention-Based Data Handling\\r\\n\\r\\nJust like [SchemaForm](/components/schema-form#convention-handling), ProTable can automatically handle common data transformations based on naming conventions.\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/convention-en/index.tsx\\" />\\r\\n\\r\\n### Storing Extra Data with innerRef\\r\\n\\r\\nNeed to pass additional data that\'s not part of the form? Use innerRef to store and access extra information, just like in [SchemaForm](/components/schema-form#storing-additional-data-with-innerref).\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/innerRefData-en/index.tsx\\" />\\r\\n\\r\\n## API\\r\\n\\r\\n### ProTable\\r\\n\\r\\nProTable combines our custom properties ([ProTableSelfType](/components/protable#protableselftype)) with the original Ant Design ProTable properties ([ProTableOriginType](/components/protable#protableorigintype)).\\r\\n\\r\\n#### ProTableSelfType\\r\\n\\r\\n<API name=\\"MyProTableSelfTypeComponent\\" />\\r\\n\\r\\n#### ProTableOriginType\\r\\n\\r\\n<API name=\\"MyProTableOriginTypeComponent\\" />\\r\\n\\r\\n### InnerRefType\\r\\n\\r\\n<API name=\\"InnerRefTypeComponent\\" typeStyles={{ minWidth: \'180px\' }} />\\r\\n\\r\\n### TableAlertOptionType\\r\\n\\r\\n<API\\r\\n  name=\\"TableAlertOptionTypeComponent\\"\\r\\n  descriptionStyles={{ minWidth: \'180px\' }}\\r\\n/>\\r\\n\\r\\n### TableColumnType\\r\\n\\r\\nSince ProTable columns work for both tables and forms, TableColumnType combines properties from [TableColumnSelfType](/components/protable#tablecolumnselftype), [TableColumnOriginType](/components/protable#tablecolumnorigintype), and [FormColumnType](/components/schema-form#formcolumntype).\\r\\n\\r\\n#### TableColumnSelfType\\r\\n\\r\\n<API name=\\"TableColumnSelfTypeComponent\\" />\\r\\n\\r\\n#### TableColumnOriginType\\r\\n\\r\\n<API name=\\"TableColumnOriginTypeComponent\\" />\\r\\n\\r\\n#### [FormColumnType](/components/schema-form#formcolumntype)\\r\\n\\r\\n### EnableDeleteType\\r\\n\\r\\n<API name=\\"EnableDeleteTypeComponent\\" />\\r\\n\\r\\n### Global Events\\r\\n\\r\\n<div className=\\"dumi-default-table-content\\">\\r\\n\\r\\n| Event Name | Description | Note |\\r\\n| --- | --- | --- |\\r\\n| @proTableReload | Triggers a table refresh from anywhere in your app using `document.dispatchEvent(new Event(\'@proTableReload\'))`. Useful when you need to refresh a table from a different page - for example, after creating a record on a separate create page. | `v1.0.0` |\\r\\n\\r\\n</div>"},{"id":"/business-select","metadata":{"permalink":"/react-admin-kit/en/components/business-select","source":"@site/i18n/en/docusaurus-plugin-content-blog-blog1/business-select/index.mdx","title":"BusinessSelect","description":"In forms, we often use dropdown components that fetch options via API (referred to as business selects). The traditional approach involves making API requests directly in the page and processing option data. However, when a page has multiple business dropdowns, this leads to the following issues:","date":"2025-02-01T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[],"frontMatter":{"date":"2025-02-01T00:00:00.000Z","sidebar_label":"BusinessSelect:0:Derived Components:1"},"unlisted":false,"prevItem":{"title":"ProTable","permalink":"/react-admin-kit/en/components/protable"},"nextItem":{"title":"BusinessTreeSelect","permalink":"/react-admin-kit/en/components/business-tree-select"}},"content":"In forms, we often use dropdown components that **fetch options via API** (referred to as business selects). The traditional approach involves making API requests directly in the page and processing option data. However, when a page has multiple business dropdowns, this leads to the following issues:\\r\\n\\r\\n1. Too much repetitive code (requests, processing, assignment)\\r\\n\\r\\n2. Some dropdowns require scroll pagination, making unified handling difficult\\r\\n\\r\\n3. Poor cross-page reusability\\r\\n\\r\\nCan we manage these components centrally? Simply put, merge all business selects into **one** component, differentiated by `type`, to achieve:\\r\\n\\r\\n- Unified management entry\\r\\n\\r\\n- Built-in pagination support\\r\\n\\r\\n- Cross-page reusability\\r\\n\\r\\nHere\'s the component initialization example:\\r\\n\\r\\n```ts\\r\\nimport { BusinessSelectBuilder } from \'react-admin-kit\';\\r\\n\\r\\n// Define type for better code hints during usage\\r\\ntype SelectType = \'color\' | \'brand\';\\r\\n\\r\\nconst BusinessSelect = BusinessSelectBuilder<SelectType>({\\r\\n  apis: [\\r\\n    {\\r\\n      type: \'color\',\\r\\n      api: queryColorFunction,\\r\\n    },\\r\\n    {\\r\\n      type: \'brand\',\\r\\n      api: queryBrandFunction,\\r\\n      pagination: true,\\r\\n    },\\r\\n  ],\\r\\n});\\r\\n\\r\\n// Usage in page\\r\\n<BusinessSelect type=\\"color\\" />;\\r\\n<BusinessSelect type=\\"brand\\" />;\\r\\n```\\r\\n\\r\\n> API response format must be `{data: [], total: xx}`. For non-paginated components, total can be omitted.\\r\\n>\\r\\n> The data is an object array where the component reads `name` as display text and `id` as dropdown value by default.\\r\\n>\\r\\n> Note: antd Select component uses `label` and `value` as text and dropdown value fields. This component uses `name` and `id` because these two values are more common in backend responses. You can change the value fields through the `fieldNames` API.\\r\\n\\r\\n## Basic Usage\\r\\n\\r\\n`BusinessSelect` is a wrapper around <Link src=\'https://ant.design/components/select#select-props\'>Antd Select</Link>, so the component can accept all antd Select properties.\\r\\n\\r\\n<Previewer src=\\"@@/BusinessSelectBuilder/demos/basic-en/index.tsx\\" />\\r\\n\\r\\n## Auto cached\\r\\n\\r\\nDropdown data is automatically cached by default, multiple references only request the API once\\r\\n\\r\\n<Previewer src=\\"@@/BusinessSelectBuilder/demos/oneQuery/index.tsx\\" />\\r\\n\\r\\n## queryParams\\r\\n\\r\\nSometimes we need to pass query parameters to the API.\\r\\n\\r\\nFor example, there\'s a user API that distinguishes different user types based on type. Page A uses type=1, and Page B uses type=2. In this case, you can use the `queryParams` property.\\r\\n\\r\\n```js\\r\\n// Page A\\r\\n<BusinessSelect type=\\"user\\" queryParams={{ type: 1 }} />\\r\\n\\r\\n// Page B\\r\\n<BusinessSelect type=\\"user\\" queryParams={{ type: 2 }} />\\r\\n```\\r\\n\\r\\n> When queryParams is passed, the dropdown will not cache data\\r\\n\\r\\n<Previewer src=\\"@@/BusinessSelectBuilder/demos/queryParams/index.tsx\\" />\\r\\n\\r\\n## Paginated dropdown and search\\r\\n\\r\\nWhen dropdown data is very large, set pagination to true in ApiType, and the component will enable pagination mode, supporting scroll-to-bottom loading of the next page and remote search.\\r\\n\\r\\nThe component will pass `current` and `searchValue` as query parameters to the API for use.\\r\\n\\r\\n```js\\r\\n// ApiType\\r\\n{\\r\\n  api: ({ current, searchValue }) => request();\\r\\n}\\r\\n```\\r\\n\\r\\n<Previewer src=\\"@@/BusinessSelectBuilder/demos/search/index.tsx\\" />\\r\\n\\r\\n## Clear cache\\r\\n\\r\\nUse the `clearSelectCache(type: string)` method to clear cache. If type is not passed, all type caches are cleared.\\r\\n\\r\\n<Previewer src=\\"@@/BusinessSelectBuilder/demos/clearCache-en/index.tsx\\" />\\r\\n\\r\\n## Define dropdown value fields\\r\\n\\r\\nThe dropdown\'s label default value is the `name` field, and the value default is `id`. If you want to change the value fields, you can use the `fieldNames` property.\\r\\n\\r\\n```js\\r\\n<BusinessSelect\\r\\n  type=\\"user\\"\\r\\n  fieldNames={{ value: \'userId\', label: \'userName\' }}\\r\\n/>\\r\\n```\\r\\n\\r\\nBesides setting it on BusinessSelect, you can also set it on BusinessSelectBuilder:\\r\\n\\r\\n```js\\r\\nBusinessSelectBuilder({\\r\\n  apis: [\\r\\n    {\\r\\n      type: \'user\'\\r\\n      defaultProps: {\\r\\n        fieldNames: {\\r\\n          value: \'userId\', label: \'userName\'\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  ]\\r\\n})\\r\\n```\\r\\n\\r\\n## onLoad event\\r\\n\\r\\nThe onLoad event is triggered when dropdown data loading is complete. This event is very useful for certain scenarios, for example, it can be used to implement default selection of the first data item.\\r\\n\\r\\n<Previewer src=\\"@@/BusinessSelectBuilder/demos/onLoad/index.tsx\\" />\\r\\n\\r\\n## API\\r\\n\\r\\n### BusinessSelectBuilder\\r\\n\\r\\n<API name=\\"BusinessSelectBuilder\\" />\\r\\n\\r\\n### ApiType\\r\\n\\r\\n<API name=\\"BizApi\\" />\\r\\n\\r\\n### BusinessSelect\\r\\n\\r\\nBusinessSelect type is a combination of [BusinessSelectSelfType](/components/business-select#businessselectselftype) and <Link src=\'https://ant.design/components/select#select-props\'>SelectProps</Link>.\\r\\n\\r\\n#### BusinessSelectSelfType\\r\\n\\r\\n<API name=\\"BusinessSelectSelf\\" />"},{"id":"/business-tree-select","metadata":{"permalink":"/react-admin-kit/en/components/business-tree-select","source":"@site/i18n/en/docusaurus-plugin-content-blog-blog1/business-tree-select/index.mdx","title":"BusinessTreeSelect","description":"Provides the same functionality as BusinessSelect, but works with tree data instead of flat lists.","date":"2025-02-02T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[],"frontMatter":{"date":"2025-02-02T00:00:00.000Z","sidebar_label":"BusinessTreeSelect:1:Derived Components:1"},"unlisted":false,"prevItem":{"title":"BusinessSelect","permalink":"/react-admin-kit/en/components/business-select"},"nextItem":{"title":"Button","permalink":"/react-admin-kit/en/components/button"}},"content":"Provides the same functionality as BusinessSelect, but works with **tree** data instead of flat lists.\\r\\n\\r\\nDefine once, use conveniently across your entire application.\\r\\n\\r\\nHere\'s the component initialization example:\\r\\n\\r\\n```js\\r\\nimport { BusinessTreeSelectBuilder } from \'react-admin-kit\';\\r\\n\\r\\n// Define type for code hinting\\r\\ntype TreeSelectType = \'org\';\\r\\n\\r\\nconst BusinessTreeSelect = BusinessTreeSelectBuilder<TreeSelectType>(\\r\\n  {\\r\\n    apis: [\\r\\n      {\\r\\n        type: \'org\',\\r\\n        api: queryOrgFunction,\\r\\n      },\\r\\n    ],\\r\\n  })\\r\\n\\r\\n// Usage in pages\\r\\n<BusinessTreeSelect type=\\"org\\" />;\\r\\n```\\r\\n\\r\\n> Since it processes tree data, pagination is not needed. The API should return an array of objects directly, with `name` as display text and `id` as value by default.\\r\\n\\r\\n## Basic Usage\\r\\n\\r\\n`BusinessTreeSelect` is a wrapper around <Link src=\'https://ant.design/components/tree-select#api\'>Antd TreeSelect</Link>, so it accepts all Antd TreeSelect properties.\\r\\n\\r\\n<Previewer src=\\"@@/BusinessTreeSelectBuilder/demos/basic-en/index.tsx\\" />\\r\\n\\r\\n## Cascading\\r\\n\\r\\n- This example shows department options cascading based on company selection.\\r\\n\\r\\n- Use `queryParams` to pass parameters to the API.\\r\\n\\r\\n<Previewer src=\\"@@/BusinessTreeSelectBuilder/demos/queryParams-en/index.tsx\\" />\\r\\n\\r\\n## Clear Cache\\r\\n\\r\\nUse `clearTreeSelectCache(type: string)` to clear cache. Omitting `type` clears all type caches.\\r\\n\\r\\n<Previewer src=\\"@@/BusinessTreeSelectBuilder/demos/clearCache-en/index.tsx\\" />\\r\\n\\r\\n## onLoad Event\\r\\n\\r\\nTriggered when dropdown data finishes loading. This event is useful for certain scenarios, such as auto-selecting the first item.\\r\\n\\r\\n<Previewer src=\\"@@/BusinessTreeSelectBuilder/demos/onLoad-en/index.tsx\\" />\\r\\n\\r\\n## API\\r\\n\\r\\n### BusinessTreeSelectBuilder\\r\\n\\r\\n<API name=\\"BusinessTreeSelectBuilder\\" />\\r\\n\\r\\n### ApiType\\r\\n\\r\\n<API name=\\"BizTreeApi\\" />\\r\\n\\r\\n### BusinessTreeSelect\\r\\n\\r\\nBusinessTreeSelect type is a combination of [BusinessTreeSelectSelfType](/components/business-tree-select#businesstreeselectselftype) and <Link src=\'https://ant.design/components/tree-select#api\'>TreeSelectProps</Link>.\\r\\n\\r\\n#### BusinessTreeSelectSelfType\\r\\n\\r\\n<API name=\\"BusinessTreeSelectSelf\\" />"},{"id":"/button","metadata":{"permalink":"/react-admin-kit/en/components/button","source":"@site/i18n/en/docusaurus-plugin-content-blog-blog1/button/index.mdx","title":"Button","description":"This component is a wrapper for Antd Button, adding a visible property for easier show/hide control. Ideal for scenarios like button permission management.","date":"2025-02-03T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[],"frontMatter":{"date":"2025-02-03T00:00:00.000Z","sidebar_label":"Button:2:Derived Components:1"},"unlisted":false,"prevItem":{"title":"BusinessTreeSelect","permalink":"/react-admin-kit/en/components/business-tree-select"},"nextItem":{"title":"LinkButton","permalink":"/react-admin-kit/en/components/link-button"}},"content":"This component is a wrapper for Antd Button, adding a `visible` property for easier show/hide control. Ideal for scenarios like button permission management.\\r\\n\\r\\n## Usage\\r\\n\\r\\n<Previewer\\r\\n  title=\\"show/hide\\"\\r\\n  src=\\"@@/Button/demos/basic-en/index.tsx\\"\\r\\n></Previewer>\\r\\n\\r\\n## API\\r\\n\\r\\n### Button\\r\\n\\r\\n<API name=\\"ButtonSelf\\"></API>"},{"id":"/link-button","metadata":{"permalink":"/react-admin-kit/en/components/link-button","source":"@site/i18n/en/docusaurus-plugin-content-blog-blog1/link-button/index.mdx","title":"LinkButton","description":"This component is a wrapper for Antd Link Button. Unlike the original Link Button, it removes the padding and white background, eliminates the fixed height, and allows it to adapt to different background colors while appearing more compact.","date":"2025-02-04T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[],"frontMatter":{"date":"2025-02-04T00:00:00.000Z","sidebar_label":"LinkButton:3:Derived Components:1"},"unlisted":false,"prevItem":{"title":"Button","permalink":"/react-admin-kit/en/components/button"},"nextItem":{"title":"FormUpload","permalink":"/react-admin-kit/en/components/form-upload"}},"content":"This component is a wrapper for Antd Link Button. Unlike the original Link Button, it removes the padding and white background, eliminates the fixed height, and allows it to adapt to different background colors while appearing more compact.\\r\\n\\r\\nIt is particularly suitable for tight spaces like table action columns.\\r\\n\\r\\n## Usage\\r\\n\\r\\n<Previewer src=\\"@@/LinkButton/demos/basic-en/index.tsx\\"></Previewer>\\r\\n\\r\\n## API\\r\\n\\r\\n### LinkButton\\r\\n\\r\\n<API name=\\"ButtonSelf\\"></API>"},{"id":"/form-upload","metadata":{"permalink":"/react-admin-kit/en/components/form-upload","source":"@site/i18n/en/docusaurus-plugin-content-blog-blog1/form-upload/index.mdx","title":"FormUpload","description":"This component is a wrapper for Antd Upload component. By managing fileList and onChange props, it behaves as a standard controlled component with value/onChange pattern, making it ready to use directly within Form.Item.","date":"2025-02-05T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[],"frontMatter":{"date":"2025-02-05T00:00:00.000Z","sidebar_label":"FormUpload:4:Derived Components:1"},"unlisted":false,"prevItem":{"title":"LinkButton","permalink":"/react-admin-kit/en/components/link-button"},"nextItem":{"title":"SettingProvider","permalink":"/react-admin-kit/en/components/setting-provider"}},"content":"This component is a wrapper for <Link src=\'https://ant-design.antgroup.com/components/upload\'>Antd Upload</Link> component. By managing `fileList` and `onChange` props, it behaves as a standard controlled component with value/onChange pattern, making it ready to use directly within `Form.Item`.\\r\\n\\r\\nThe design goal of `FormUpload` is to provide a simple, lightweight experience similar to using an `Input` component after basic global configuration. Successfully uploaded files are automatically collected by the form, while failed uploads are filtered out.\\r\\n\\r\\n## Basic Usage\\r\\n\\r\\nConfigure essential props like `action` and `headers` globally before use:\\r\\n\\r\\n```js\\r\\n<SettingProvider\\r\\n  formUploadSetting={{\\r\\n    action: \'https://mock.apifox.cn/m1/1864670-0-default/mockUpload\',\\r\\n    headers: { Authorization: \'myToken\' },\\r\\n    responseToFileList: (res) => ({ id: res?.data.id }), // Merge API response into file object\\r\\n    children: ({ loading }) => (\\r\\n      <LinkButton disabled={loading}>\\r\\n        {loading ? \'Uploading...\' : \'Upload File\'}\\r\\n      </LinkButton>\\r\\n    ),\\r\\n  }}\\r\\n>\\r\\n  ...\\r\\n</SettingProvider>\\r\\n```\\r\\n\\r\\nThe component\'s children can use render function:\\r\\n\\r\\n```js\\r\\n<FormUpload>\\r\\n  {({loading} => <Button disabled={loading}>{loading ? \'Uploading...\' : \'Upload\'}</Button>)}\\r\\n</FormUpload>\\r\\n```\\r\\n\\r\\n<Previewer src=\\"@@/FormUpload/demos/basic-en/index.tsx\\" />\\r\\n\\r\\n## Upload Failures\\r\\n\\r\\n- You can configure error notifications globally.\\r\\n- Failed files won\'t be collected by the form.\\r\\n\\r\\n<Previewer src=\\"@@/FormUpload/demos/errorHandle-en/index.tsx\\" />\\r\\n\\r\\n## File Initial Values\\r\\n\\r\\n> Files where beforeUpload returns false are excluded from form collection.\\r\\n\\r\\n<Previewer src=\\"@@/FormUpload/demos/show-en/index.tsx\\" />\\r\\n\\r\\n## Data Processing and Collection\\r\\n\\r\\n`SchemaForm` provides `convertValue` and `transform` for data processing:\\r\\n\\r\\n- convertValue - Pre-processes initial values\\r\\n- transform - Processes data before submission\\r\\n\\r\\n> `FormUpload` component expects file objects in format: `{ name: string; url: string }` by default\\r\\n>\\r\\n> This example shows how to use convertValue and transform for data conversion when backend returns non-conforming data.\\r\\n\\r\\n<Previewer src=\\"@@/FormUpload/demos/dataSubmit-en/index.tsx\\" />\\r\\n\\r\\n## Change Field Keys\\r\\n\\r\\nFormUpload also provides `nameKey` and `urlKey` to customize file object field mapping. Global configuration is also supported.\\r\\n\\r\\n<Previewer src=\\"@@/FormUpload/demos/changeKey-en/index.tsx\\" />\\r\\n\\r\\n## File Import\\r\\n\\r\\n`FormUpload` component can also be used for file import scenarios. File import differs from file attachment upload in that each new imported file should replace previous files, while attachment upload logic adds newly uploaded files to the existing file list.\\r\\n\\r\\nTo achieve this replacement effect, you can clear the list after import completion.\\r\\n\\r\\n<Previewer src=\\"@@/FormUpload/demos/import-en/index.tsx\\" />\\r\\n\\r\\n## API\\r\\n\\r\\n### FormUpload\\r\\n\\r\\nFormUpload type is a combination of [FormUploadSelfType](/components/form-upload#formuploadselftype) and <Link src=\'https://ant-design.antgroup.com/components/upload#api\'>UploadProps</Link>.\\r\\n\\r\\n#### FormUploadSelfType\\r\\n\\r\\n<API name=\\"FormUploadType\\" />\\r\\n\\r\\n## FAQ\\r\\n\\r\\n### What is responseToFileList?\\r\\n\\r\\nAfter successful file upload, the default collected data looks like:\\r\\n\\r\\n```js\\r\\n{\\r\\n  uid: \'rc-upload-1691485494798-17\',\\r\\n  name: \'xx.png\',\\r\\n  size: 1403,\\r\\n  status: \'done\',\\r\\n  response: {\\r\\n    // Backend response after successful upload\\r\\n    id: 123,\\r\\n    filePath: \'xxx\'\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\nThe responseToFileList function can merge the above response into the file object.\\r\\n\\r\\nFor example: `responseToFileList: (res) => ({ id: res.id })`, the final submitted object will have the id:\\r\\n\\r\\n```js\\r\\n{\\r\\n  id: 123,\\r\\n  uid: \'rc-upload-1691485494798-17\',\\r\\n  name: \'xx.png\',\\r\\n  size: 1403,\\r\\n  status: \'done\',\\r\\n  response: {\\r\\n    // Backend response after successful upload\\r\\n    id: 123,\\r\\n    filePath: \'xxx\'\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\nGenerally this property can be set globally in the `SettingProvider` component."},{"id":"/setting-provider","metadata":{"permalink":"/react-admin-kit/en/components/setting-provider","source":"@site/i18n/en/docusaurus-plugin-content-blog-blog1/setting-provider/index.mdx","title":"SettingProvider","description":"Provides unified default settings for components. Wrap once at the outer level to take effect globally.","date":"2025-03-01T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[],"frontMatter":{"date":"2025-03-01T00:00:00.000Z","sidebar_label":"SettingProvider:0:Default Settings:2"},"unlisted":false,"prevItem":{"title":"FormUpload","permalink":"/react-admin-kit/en/components/form-upload"},"nextItem":{"title":"Internationalization (i18n)","permalink":"/react-admin-kit/en/components/i18n"}},"content":"Provides unified default settings for components. Wrap once at the outer level to take effect globally.\\r\\n\\r\\n## SchemaForm\\r\\n\\r\\nFor example, you can uniformly configure the default validation messages for SchemaForm.\\r\\n\\r\\n<Previewer src=\\"@@/SettingProvider/demos/schemaForm-en\\" />\\r\\n\\r\\n## ModalForm\\r\\n\\r\\nFor example, you can uniformly configure the default layout for modal forms.\\r\\n\\r\\n<Previewer src=\\"@@/SettingProvider/demos/modalForm-en\\" />\\r\\n\\r\\nOr you can uniformly configure the default width for modal forms.\\r\\n\\r\\n<Previewer src=\\"@@/SettingProvider/demos/modalForm-width-en\\" />\\r\\n\\r\\n## ProTable\\r\\n\\r\\nFor example, you can uniformly configure pagination options.\\r\\n\\r\\n<Previewer src=\\"@@/SettingProvider/demos/protable-pagination-en\\" />\\r\\n\\r\\nOr uniformly configure the search area.\\r\\n\\r\\n<Previewer src=\\"@@/SettingProvider/demos/protable-search-en\\" />\\r\\n\\r\\nOr uniformly configure the table size.\\r\\n\\r\\n<Previewer src=\\"@@/SettingProvider/demos/protable-size-en\\" />\\r\\n\\r\\n## FormUpload\\r\\n\\r\\nYou can uniformly set properties like `action`, `header`, `children`, `responseToFileList` here.\\r\\n\\r\\n<Previewer src=\\"@@/FormUpload/demos/basic-en\\" />\\r\\n\\r\\n## API\\r\\n\\r\\n### SettingProvider\\r\\n\\r\\n<API name=\\"SettingProvider\\" />\\r\\n\\r\\n### SchemaFormSettingProps\\r\\n\\r\\n<API name=\\"SchemaFormSettingPropsType\\" />\\r\\n\\r\\n### ModalFormSettingProps\\r\\n\\r\\n<API name=\\"ModalFormSettingPropsType\\" />\\r\\n\\r\\n### ProTableSettingProps\\r\\n\\r\\n<API name=\\"ProTableSettingPropsType\\" />\\r\\n\\r\\n### FormUploadSettingProps\\r\\n\\r\\n<API name=\\"FormUploadSettingPropsType\\" />"},{"id":"/i18n","metadata":{"permalink":"/react-admin-kit/en/components/i18n","source":"@site/i18n/en/docusaurus-plugin-content-blog-blog1/i18n/index.mdx","title":"Internationalization (i18n)","description":"Since RAK wraps Antd and Antd ProComponents, RAK\'s internationalization requires configuring Antd and Antd ProComponents in addition to RAK itself.","date":"2025-04-01T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[],"frontMatter":{"date":"2025-04-01T00:00:00.000Z","sidebar_label":"i18n:1:Default Settings:2"},"unlisted":false,"prevItem":{"title":"SettingProvider","permalink":"/react-admin-kit/en/components/setting-provider"},"nextItem":{"title":"Tree Data","permalink":"/react-admin-kit/en/components/utils-tree"}},"content":"Since RAK wraps Antd and Antd ProComponents, RAK\'s internationalization requires configuring Antd and Antd ProComponents in addition to RAK itself.\\r\\n\\r\\n<Previewer src=\\"@@/ProTable/demos/i18n\\"  />\\r\\n\\r\\nRAK itself has minimal multilingual text, so other languages can be created by modifying the English version."},{"id":"/utils-tree","metadata":{"permalink":"/react-admin-kit/en/components/utils-tree","source":"@site/i18n/en/docusaurus-plugin-content-blog-blog1/utils-tree/index.mdx","title":"Tree Data","description":"Provides utility methods for handling tree data.","date":"2025-05-01T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[],"frontMatter":{"date":"2025-05-01T00:00:00.000Z","sidebar_label":"Tree Data:0:Utils:3"},"unlisted":false,"prevItem":{"title":"Internationalization (i18n)","permalink":"/react-admin-kit/en/components/i18n"}},"content":"Provides utility methods for handling tree data.\\r\\n\\r\\n```js\\r\\nimport { normalizeTree } from \'react-admin-kit/utils\';\\r\\n```\\r\\n\\r\\n> Open your browser\'s developer tools and use `_.normalizeTree` for debugging.\\r\\n\\r\\n## normalizeTree\\r\\n\\r\\nNormalizes tree data structure by processing each node through the provided patch function.\\r\\n\\r\\n```tsx\\r\\nfunction normalizeTree(\\r\\n  data: any[] = [],\\r\\n  patchFunction?: (item: any) => Record<string, any> | undefined,\\r\\n  options?: { replace: boolean },\\r\\n): any[];\\r\\n```\\r\\n\\r\\n**Parameters**\\r\\n\\r\\n- `data` - Tree data array\\r\\n- `patchFunction` - Function to process each node, returns an object of properties to merge or replace\\r\\n- `options.replace` - Whether to completely replace the original node with the patch result, defaults to false (merge mode)\\r\\n\\r\\n### Basic Usage\\r\\n\\r\\n```js\\r\\n// Add disabled property to each node\\r\\nconst data = [\\r\\n  { id: 1, name: \'Node 1\', children: [{ id: 2, name: \'Node 2\' }] },\\r\\n  { id: 3, name: \'Node 3\' },\\r\\n];\\r\\n\\r\\nconst result = normalizeTree(data, (item) => ({ disabled: true }));\\r\\n// Result: Each node will have the disabled: true property added\\r\\n```\\r\\n\\r\\n### Conditional Processing\\r\\n\\r\\n```js\\r\\n// Dynamically add styles based on node properties\\r\\nconst menuData = [\\r\\n  { key: \'home\', title: \'Home\', type: \'page\' },\\r\\n  {\\r\\n    key: \'users\',\\r\\n    title: \'User Management\',\\r\\n    type: \'menu\',\\r\\n    children: [{ key: \'user-list\', title: \'User List\', type: \'page\' }],\\r\\n  },\\r\\n];\\r\\n\\r\\nconst normalizedMenu = normalizeTree(menuData, (item) => {\\r\\n  if (item.type === \'menu\') {\\r\\n    return { icon: \'folder\', expandable: true };\\r\\n  }\\r\\n  if (item.type === \'page\') {\\r\\n    return { icon: \'file\', clickable: true };\\r\\n  }\\r\\n});\\r\\n```\\r\\n\\r\\n### Replace Mode\\r\\n\\r\\n```js\\r\\n// Completely restructure node format\\r\\nconst rawData = [{ id: 1, label: \'Item 1\', sub: [{ id: 2, label: \'Item 2\' }] }];\\r\\n\\r\\nconst transformed = normalizeTree(\\r\\n  rawData,\\r\\n  (item) => ({\\r\\n    value: item.id,\\r\\n    title: item.label,\\r\\n    children: item.sub,\\r\\n  }),\\r\\n  { replace: true },\\r\\n);\\r\\n// Result: Node structure is completely replaced with the new format\\r\\n```"}]}}')}}]);